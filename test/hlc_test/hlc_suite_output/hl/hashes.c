// Generated by HLC 4.3.7 (HL v4)
#define HLC_BOOT
#include <hlc.h>


void hl_init_hashes() {
	hl_hash((vbyte*)USTR("__type__"));
	hl_hash((vbyte*)USTR("__meta__"));
	hl_hash((vbyte*)USTR("__implementedBy__"));
	hl_hash((vbyte*)USTR("check"));
	hl_hash((vbyte*)USTR("__name__"));
	hl_hash((vbyte*)USTR("__constructor__"));
	hl_hash((vbyte*)USTR("bytes"));
	hl_hash((vbyte*)USTR("length"));
	hl_hash((vbyte*)USTR("toUpperCase"));
	hl_hash((vbyte*)USTR("toLowerCase"));
	hl_hash((vbyte*)USTR("charAt"));
	hl_hash((vbyte*)USTR("charCodeAt"));
	hl_hash((vbyte*)USTR("findChar"));
	hl_hash((vbyte*)USTR("indexOf"));
	hl_hash((vbyte*)USTR("lastIndexOf"));
	hl_hash((vbyte*)USTR("split"));
	hl_hash((vbyte*)USTR("substr"));
	hl_hash((vbyte*)USTR("substring"));
	hl_hash((vbyte*)USTR("toString"));
	hl_hash((vbyte*)USTR("toUtf8"));
	hl_hash((vbyte*)USTR("__string"));
	hl_hash((vbyte*)USTR("__compare"));
	hl_hash((vbyte*)USTR("fromCharCode"));
	hl_hash((vbyte*)USTR("__alloc__"));
	hl_hash((vbyte*)USTR("call_toString"));
	hl_hash((vbyte*)USTR("fromUCS2"));
	hl_hash((vbyte*)USTR("fromUTF8"));
	hl_hash((vbyte*)USTR("__add__"));
	hl_hash((vbyte*)USTR("testsRun"));
	hl_hash((vbyte*)USTR("testsPassed"));
	hl_hash((vbyte*)USTR("assert"));
	hl_hash((vbyte*)USTR("testBasicTypes"));
	hl_hash((vbyte*)USTR("testArrays"));
	hl_hash((vbyte*)USTR("testMaps"));
	hl_hash((vbyte*)USTR("testStrings"));
	hl_hash((vbyte*)USTR("testMath"));
	hl_hash((vbyte*)USTR("testClasses"));
	hl_hash((vbyte*)USTR("testStaticMembers"));
	hl_hash((vbyte*)USTR("testEnums"));
	hl_hash((vbyte*)USTR("testExceptions"));
	hl_hash((vbyte*)USTR("main"));
	hl_hash((vbyte*)USTR("allocI32"));
	hl_hash((vbyte*)USTR("allocUI16"));
	hl_hash((vbyte*)USTR("allocF32"));
	hl_hash((vbyte*)USTR("allocF64"));
	hl_hash((vbyte*)USTR("getDyn"));
	hl_hash((vbyte*)USTR("setDyn"));
	hl_hash((vbyte*)USTR("blit"));
	hl_hash((vbyte*)USTR("pushDyn"));
	hl_hash((vbyte*)USTR("popDyn"));
	hl_hash((vbyte*)USTR("shiftDyn"));
	hl_hash((vbyte*)USTR("unshiftDyn"));
	hl_hash((vbyte*)USTR("insertDyn"));
	hl_hash((vbyte*)USTR("containsDyn"));
	hl_hash((vbyte*)USTR("removeDyn"));
	hl_hash((vbyte*)USTR("sortDyn"));
	hl_hash((vbyte*)USTR("slice"));
	hl_hash((vbyte*)USTR("splice"));
	hl_hash((vbyte*)USTR("join"));
	hl_hash((vbyte*)USTR("reverse"));
	hl_hash((vbyte*)USTR("resize"));
	hl_hash((vbyte*)USTR("__cast"));
	hl_hash((vbyte*)USTR("isArrayObj"));
	hl_hash((vbyte*)USTR("size"));
	hl_hash((vbyte*)USTR("concat"));
	hl_hash((vbyte*)USTR("pop"));
	hl_hash((vbyte*)USTR("push"));
	hl_hash((vbyte*)USTR("shift"));
	hl_hash((vbyte*)USTR("sort"));
	hl_hash((vbyte*)USTR("unshift"));
	hl_hash((vbyte*)USTR("insert"));
	hl_hash((vbyte*)USTR("contains"));
	hl_hash((vbyte*)USTR("remove"));
	hl_hash((vbyte*)USTR("copy"));
	hl_hash((vbyte*)USTR("iterator"));
	hl_hash((vbyte*)USTR("keyValueIterator"));
	hl_hash((vbyte*)USTR("map"));
	hl_hash((vbyte*)USTR("filter"));
	hl_hash((vbyte*)USTR("__expand"));
	hl_hash((vbyte*)USTR("formatOutput"));
	hl_hash((vbyte*)USTR("trace"));
	hl_hash((vbyte*)USTR("className"));
	hl_hash((vbyte*)USTR("customParams"));
	hl_hash((vbyte*)USTR("fileName"));
	hl_hash((vbyte*)USTR("lineNumber"));
	hl_hash((vbyte*)USTR("methodName"));
	hl_hash((vbyte*)USTR("array"));
	hl_hash((vbyte*)USTR("allowReinterpret"));
	hl_hash((vbyte*)USTR("get_length"));
	hl_hash((vbyte*)USTR("__get_field"));
	hl_hash((vbyte*)USTR("score"));
	hl_hash((vbyte*)USTR("highScore"));
	hl_hash((vbyte*)USTR("addPoints"));
	hl_hash((vbyte*)USTR("getHighScore"));
	hl_hash((vbyte*)USTR("reset"));
	hl_hash((vbyte*)USTR("__ename__"));
	hl_hash((vbyte*)USTR("__emap__"));
	hl_hash((vbyte*)USTR("__constructs__"));
	hl_hash((vbyte*)USTR("__evalues__"));
	hl_hash((vbyte*)USTR("rnd"));
	hl_hash((vbyte*)USTR("toStringDepth"));
	hl_hash((vbyte*)USTR("string"));
	hl_hash((vbyte*)USTR("min"));
	hl_hash((vbyte*)USTR("max"));
	hl_hash((vbyte*)USTR("PI"));
	hl_hash((vbyte*)USTR("NaN"));
	hl_hash((vbyte*)USTR("POSITIVE_INFINITY"));
	hl_hash((vbyte*)USTR("NEGATIVE_INFINITY"));
	hl_hash((vbyte*)USTR("sub"));
	hl_hash((vbyte*)USTR("utf8Path"));
	hl_hash((vbyte*)USTR("println"));
	hl_hash((vbyte*)USTR("init"));
	hl_hash((vbyte*)USTR("initClass"));
	hl_hash((vbyte*)USTR("initEnum"));
	hl_hash((vbyte*)USTR("register"));
	hl_hash((vbyte*)USTR("saveStack"));
	hl_hash((vbyte*)USTR("exceptionStack"));
	hl_hash((vbyte*)USTR("rec"));
	hl_hash((vbyte*)USTR("doMerge"));
	hl_hash((vbyte*)USTR("rotate"));
	hl_hash((vbyte*)USTR("gcd"));
	hl_hash((vbyte*)USTR("upper"));
	hl_hash((vbyte*)USTR("lower"));
	hl_hash((vbyte*)USTR("swap"));
	hl_hash((vbyte*)USTR("alloc"));
	hl_hash((vbyte*)USTR("t"));
	hl_hash((vbyte*)USTR("h"));
	hl_hash((vbyte*)USTR(""));
	hl_hash((vbyte*)USTR("set"));
	hl_hash((vbyte*)USTR("get"));
	hl_hash((vbyte*)USTR("exists"));
	hl_hash((vbyte*)USTR("keys"));
	hl_hash((vbyte*)USTR("hasNext"));
	hl_hash((vbyte*)USTR("next"));
	hl_hash((vbyte*)USTR("name"));
	hl_hash((vbyte*)USTR("health"));
	hl_hash((vbyte*)USTR("takeDamage"));
	hl_hash((vbyte*)USTR("heal"));
	hl_hash((vbyte*)USTR("b"));
	hl_hash((vbyte*)USTR("pos"));
	hl_hash((vbyte*)USTR("add"));
	hl_hash((vbyte*)USTR("addChar"));
	hl_hash((vbyte*)USTR("msg"));
	hl_hash((vbyte*)USTR("__exceptionMessage"));
	hl_hash((vbyte*)USTR("__nativeStack"));
	hl_hash((vbyte*)USTR("__nativeException"));
	hl_hash((vbyte*)USTR("__previousException"));
	hl_hash((vbyte*)USTR("get_message"));
	hl_hash((vbyte*)USTR("arr"));
	hl_hash((vbyte*)USTR("posInfos"));
	hl_hash((vbyte*)USTR("current"));
	hl_hash((vbyte*)USTR("a"));
}
